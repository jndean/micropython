#!/usr/bin/env python3

import argparse
import subprocess
from tempfile import NamedTemporaryFile


# Code tempaltes for insertion
POPPPY_HEADER="""
// ------------------------ This code was inserted by poppyc -------------------------- //
#include <poplar/Vertex.hpp>
#include "poplar/StackSizeDefs.hpp" 
#define RECURSIVE_FUNCTION_SIZE (5 * 1024)
DEF_STACK_USAGE(RECURSIVE_FUNCTION_SIZE, "poppy_init");
extern "C" void poppy_deinit(void);
DEF_STACK_USAGE(RECURSIVE_FUNCTION_SIZE, "poppy_deinit");
DEF_STACK_USAGE(RECURSIVE_FUNCTION_SIZE, "poppy_add_memory_as_array");
DEF_STACK_USAGE(RECURSIVE_FUNCTION_SIZE, "poppy_do_str");
extern "C" void poppy_init(char *stdout_memory, char *poplar_stack_bottom);
extern "C" void poppy_add_memory_as_array(const char* name, void* data, size_t num_elts);
extern "C" void poppy_do_str(const char *src, int is_single_line);
// ------------------------ This code was inserted by poppyc -------------------------- //
"""
POPPY_START_LINES="""
{indent}// ------------------------ This code was generated by poppyc -------------------------- //
{indent}char* poplar_stack_bottom;
{indent}asm volatile("mov %[poplar_stack_bottom], $m11" : [poplar_stack_bottom] "+r" (poplar_stack_bottom) ::);
{indent}poppy_init({stdout_name}, poplar_stack_bottom);
"""
POPPY_VARIABLE_LINE="""{indent}poppy_add_memory_as_array("{pyname}", &{cppname}[0], {cppname}.size());"""
POPPY_END_LINES="""
{indent}poppy_do_str("{payload}", 0);
{indent}poppy_deinit();
{indent}// ------------------------- This code was generated by poppyc ------------------------ //
"""


def preprocess_block(lines):
    header, python_lines = lines[0], lines[1:]

    # The position of the #pragma defines the indentation of the python block
    indent = header[:header.find('#pragma')]

    # Parse the variable name map, creating python arrays for each
    # Special handling for stdout, if present
    var_lines = []
    stdout_name = "NULL"
    var_list = ' '.join(header.split()[2:])
    assert(var_list[0] == '[' and var_list[-1]==']')
    for item in var_list[1:-1].split(','):
        pyname, cppname = item.split("=") if '=' in item else (item, item)
        pyname, cppname = pyname.strip(), cppname.strip()
        if pyname == 'stdout':
            stdout_name = '&' + cppname + '[0]'
            continue
        var_lines.append(POPPY_VARIABLE_LINE.format(indent=indent, pyname=pyname, cppname=cppname))

    # Dedent python lines and fuse into a string for execution
    payload = ""
    for line in filter(lambda ln: ln.strip(), python_lines):  # (Non-empty lines only)
        assert(line.startswith(indent))
        assert("\"" not in line)
        line = line.replace('\\', '\\\\')
        payload += line[len(indent):] + '\\n'      

    out_lines = [
        POPPY_START_LINES.format(indent=indent, stdout_name=stdout_name)
    ] + var_lines + [
        POPPY_END_LINES.format(indent=indent, payload=payload),
    ]
    return out_lines
    


def preprocess_file(src):
    current_block = []
    output_lines = [POPPPY_HEADER]

    for line in src.splitlines():
        line_start = ' '.join(line.split()[:2])

        # Not already in a poppy block
        if not current_block:
            # Enter a new block
            if line_start == '#pragma poppy_start':
                current_block.append(line)
            elif line_start == '#pragma poppy_end':
                raise RuntimeError("Found python block end outside a python block")
            else:
                output_lines.append(line)
            continue
            
        # We're in a block, is this the end?
        if line_start == '#pragma poppy_end':
            output_lines.extend(preprocess_block(current_block))
            current_block = []
            continue

        # Stay in the block
        current_block.append(line)

    if current_block:
        raise RuntimeError("End of file found inside python block")

    return '\n'.join(output_lines)


def main(args, popc_args):
    with open(args.infile, 'r') as f:
        src = preprocess_file(f.read())

    if args.preprocess_only:
        with open(args.outfile, 'w') as f:
            f.write(src)
        return

    with NamedTemporaryFile('w', suffix='.cpp') as src_on_disk:
        src_on_disk.write(src)
        src_on_disk.flush()
        result = subprocess.run(
            ["popc", src_on_disk.name, "-o", args.outfile] + popc_args,
            stderr=subprocess.PIPE, encoding="UTF-8"
        )
        if result.returncode:
            print('Call to popc failed with following stderr output:')
            print(result.stderr)


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Run popc, with poppy preprocessing')
    parser.add_argument('--infile', '-i', required=True, help='cpp file to compile')
    parser.add_argument('--outfile', '-o', required=True, help='Compiled destination file')
    parser.add_argument('--preprocess_only', action='store_true', help='Skip compilation, output preprocesses')
    parser.add_argument('--target', default='ipu2', help="Default target flag to pass to popc")

    poppyc_args, popc_args = parser.parse_known_args()

    popc_args.append('--target={}'.format(poppyc_args.target))
    del poppyc_args.target

    main(poppyc_args, popc_args)